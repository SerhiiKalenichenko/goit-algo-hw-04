# ДЗ 4. Алгоритми сортування  

---

## 1. Мета роботи

Порівняти ефективність трьох алгоритмів сортування:

- **Insertion Sort** — сортування вставками  
- **Merge Sort** — сортування злиттям  
- **Timsort** — вбудований алгоритм `sorted()`  

Тестування виконано на масивах різних типів (випадкові, майже відсортовані, зворотні).  
Для вимірювання часу використано модуль `timeit`.

---

## 2. Короткі результати

- **Insertion Sort**  
  Повільний на середніх та великих наборах даних. Придатний лише для малих або майже відсортованих списків.

- **Merge Sort**  
  Стабільна продуктивність `O(n log n)` у всіх варіантах тестування.

- **Timsort (sorted)**  
  Найшвидший алгоритм у всіх тестах. Особливо ефективний на частково впорядкованих масивах.

Емпіричні дані підтвердили теоретичні оцінки складності.

---

## 3. Висновок

Timsort поєднує переваги сортування вставками та злиттям, адаптується до структури даних і забезпечує найвищу ефективність.  
Саме тому Python використовує його як основний алгоритм сортування, а розробники — обирають `sorted()` замість ручних реалізацій.

---

## 4. Опціональне завдання

Реалізовано функцію об’єднання `k` відсортованих списків:

```python
def merge_k_lists(lists):
    heap = []
    result = []
    for list_index, lst in enumerate(lists):
        if lst:
            heappush(heap, (lst[0], list_index, 0))
    while heap:
        value, list_index, element_index = heappop(heap)
        result.append(value)
        next_index = element_index + 1
        if next_index < len(lists[list_index]):
            heappush(heap, (lists[list_index][next_index], list_index, next_index))
    return result

Результат відповідає прикладу із завдання
Складність: O(N log k). 
